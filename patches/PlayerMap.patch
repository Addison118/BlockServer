### Eclipse Workspace Patch 1.0
#P BlockServer
diff --git src/java/org/blockserver/Server.java src/java/org/blockserver/Server.java
index 95208fb..115b809 100644
--- src/java/org/blockserver/Server.java
+++ src/java/org/blockserver/Server.java
@@ -19,6 +19,7 @@
 import org.blockserver.player.PlayerDatabase;
 import org.blockserver.scheduler.Scheduler;
 import org.blockserver.utility.MinecraftVersion;
+import org.blockserver.utility.PlayerMap;
 import org.blockserver.utility.ServerLogger;
 
 public class Server implements Context{
@@ -310,7 +311,7 @@
 		MCVERSION = version;
 		this.motd = motd;
 		serverID = new Random().nextLong();
-		players = new HashMap<String, Player>(maxPlayers);
+		players = new PlayerMap(maxPlayers);
 		this.playersDir = playersDir;
 		worldsDir.mkdirs();
 		this.worldsDir = worldsDir;
diff --git src/java/org/blockserver/utility/PlayerMap.java src/java/org/blockserver/utility/PlayerMap.java
new file mode 100644
index 0000000..a924381
--- /dev/null
+++ src/java/org/blockserver/utility/PlayerMap.java
@@ -0,0 +1,157 @@
+package org.blockserver.utility;
+
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.blockserver.player.Player;
+
+public class PlayerMap implements Map<String, Player>{
+	private String[] names;
+	private Player[] players;
+	private int size = 0;
+	public PlayerMap(int size){
+		names = new String[size];
+		players = new Player[size];
+	}
+	@Override
+	public void clear(){
+		for(int i = 0; i < names.length; i++){
+			names[i] = null;
+			players[i] = null;
+		}
+		size = 0;
+	}
+
+	@Override
+	public boolean containsKey(Object key){
+		if(key == null){
+			return false;
+		}
+		for(String name: names){
+			if(key.equals(name)){
+				return true;
+			}
+		}
+		return false;
+	}
+
+	@Override
+	public boolean containsValue(Object value){
+		if(value == null){
+			return false;
+		}
+		for(Player player: players){
+			if(value.equals(player)){
+				return true;
+			}
+		}
+		return false;
+	}
+
+	@Override
+	public Set<Map.Entry<String, Player>> entrySet(){
+		Set<Map.Entry<String, Player>> ret = new HashSet<Map.Entry<String, Player>>(size);
+		for(int i = 0; i < names.length; i++){
+			if(names[i] != null){
+				ret.add(new AbstractMap.SimpleEntry<String, Player>(names[i], players[i]));
+			}
+		}
+		return ret;
+	}
+
+	@Override
+	public Player get(Object key){
+		if(key == null){
+			return null;
+		}
+		int i = 0;
+		for(String name: names){
+			if(key.equals(name)){
+				return players[i];
+			}
+			i++;
+		}
+		return null;
+	}
+
+	@Override
+	public boolean isEmpty(){
+		return size == 0;
+	}
+
+	@Override
+	public Set<String> keySet(){
+		Set<String> ret = new HashSet<String>(size);
+		for(String name: names){
+			if(name != null){
+				ret.add(name);
+			}
+		}
+		return ret;
+	}
+
+	@Override
+	public Player put(String key, Player value){
+		if(size == names.length){
+			throw new IndexOutOfBoundsException("Max number of players reached!");
+		}
+		int s = -1;
+		size++;
+		for(int i = 0; i < names.length; i++){
+			if(names[i] == null && s == -1){
+				s = i;
+			}
+			else if(names[i].equals(key)){
+				Player result = players[i];
+				names[i] = key;
+				players[i] = value;
+				return result;
+			}
+		}
+		names[s] = key;
+		players[s] = value;
+		return null;
+	}
+
+	@Override
+	public void putAll(Map<? extends String, ? extends Player> m){
+		for(Map.Entry<? extends String, ? extends Player> entry: m.entrySet()){
+			put(entry.getKey(), entry.getValue());
+		}
+	}
+
+	@Override
+	public Player remove(Object key){
+		for(int i = 0; i < names.length; i++){
+			if(names[i] == null){
+				continue;
+			}
+			if(names[i].equals(key)){
+				Player result = players[i];
+				names[i] = null;
+				players[i] = null;
+				size--;
+				return result;
+			}
+		}
+		return null;
+	}
+
+	@Override
+	public int size(){
+		return size;
+	}
+
+	@Override
+	public Collection<Player> values(){
+		Collection<Player> players = new ArrayList<Player>(size);
+		for(Player p: this.players){
+			players.add(p);
+		}
+		return players;
+	}
+}
\ No newline at end of file